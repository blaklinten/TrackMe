#!/bin/bash

#########################################################
# This is a script that helps me keep track of my time. #
#########################################################
# These are the configuration options
#
export GITSYNC="no"

###### TODO ######
# Fix info if    #
# git is not     #
# available      #
##################

export WD="$HOME/Git/TrackMe"
export CLIENTS="$HOME/.trackme"
export ACTIVE="$CLIENTS/active"
export EVENT_FILE="$CLIENTS/events"

if [[ ! -d "$CLIENTS" ]]; then
    mkdir -p "$CLIENTS"
    echo "Creating working env..."
fi

########################
# Git helper functions #
########################

gitPull()
{
	pushd "$CLIENTS" &> /dev/null
	git pull &> /dev/null
	popd &> /dev/null
}

gitPush()
{
	ACTIVITY="$1"
	PROJECT="$2"

	pushd "$CLIENTS" &> /dev/null
	git commit -am "Time entry for $ACTIVITY, $PROJECT" &> /dev/null
	git push &> /dev/null
	popd &> /dev/null
}

gitAdd()
{
    NEW_ACTIVITY="$1"

	pushd "$CLIENTS" &> /dev/null
	git add "$NEW_ACTIVITY" &> /dev/null
	popd &> /dev/null

}

####################
# Getting feedback #
####################

show()
{
	INFO="$1"
	CHOICES="$2"
	echo "$CHOICES" | sed -e 's/ /\n/g' | dmenu -i -p "$INFO"
}

showStatus()
{
    if [[ ! -f "$ACTIVE" ]]; then
        show "No active timer running!"
        return
    fi

    ACTIVITY=$(tail -n 3 "$ACTIVE" | head -n 1 )
    PROJECT=$(tail -n 3 "$ACTIVE" | head -n 2 | tail -n 1)
    START=$(tail -n 1 "$ACTIVE")
    END=$(date +%s)

    show "Timer running for $(parseUnderscores $ACTIVITY) on $PROJECT Started at $(date --date="@$START"). Running for $(diff "$START" "$END")."
}

#######################
# Text transformation #
#######################

parseSpaces()
{
    echo "$(echo $@ | sed s/\ /\_/g)"
}

parseUnderscores()
{
    echo "$(echo $@ | sed s/\_/\ /g)"
}

###############################
# Manage clients and projects #
###############################

chooseClient()
{
	SCRIPT=$1

	ANS="$(show "Choose an existing client, create a (n)ew, (s)ummarize by time or (q)uit:" "$(ls $CLIENTS)")"
	CHOICE="$(parseSpaces "$ANS")"

	case "$CHOICE" in
        "q")
            show "Exiting..."
            pkill trackMe
            exit
        ;;
        "n")
            createClient
            return
       ;;
       "s")
            TIME="$(show "Sum entries from when? (leave empty for 12h)")"
            sumEntries "$TIME"
       ;;
       *)
            pushd "$CLIENTS" > /dev/zero
            for CLIENT in *; do
                if [[ "$CLIENT" == "$CHOICE" ]]; then
                    popd > /dev/zero
                    return
                fi
            done
                show "Client \"$CHOICE\" does not exist, try again or create it (n)."
                chooseClient "$SCRIPT"
       ;;
	esac
}

chooseProject()
{
	SCRIPT="$1"
	ANS="$(show "Choose an existing project, create a (n)ew or (q)uit" "$(ls $PROJECTS)")"
	CHOICE="$(parseSpaces "$ANS")"

	case $CHOICE in
    	"q")
        	exit
        ;;
    	"n")
        	createProject "$SCRIPT"
        ;;
    	*)
        	pushd "$PROJECTS" > /dev/zero
        	for PROJECT in *; do
            	if [[ "$PROJECT" == "$CHOICE" ]]; then
                	"$SCRIPT" "$CHOICE"
                	popd > /dev/zero
                	return
            	fi
        	done
        	show "Project \"$(parseUnderscores "$CHOICE")\" does not exist, try again or create it (n)."
            chooseProject "$SCRIPT"
            return
        ;;
	esac
}

createClient()
{
	SCRIPT="$1"
	ANS="$(show "Enter name of new client:")"
	CLIENT=$(parseSpaces "$ANS")

	mkdir "$CLIENTS/$CLIENT"

	chooseClient "$SCRIPT"
}

createProject()
{
	SCRIPT="$1"
	ANS="$(show "Enter name of new project:")"
	projectName=$(parseSpaces "$ANS")

	mkdir "$PROJECTS/$projectName"

	chooseProject "$SCRIPT"
}

#####################
# Manage Activities #
#####################

startActivity()
{
	PROJECT="$1"

	if [[ "$GITSYNC" == "yes" ]]; then
    	gitPull & disown
	fi

	ANS="$(show "What are you doing?" "new quit $(ls $PROJECTS/$PROJECT)")"
	case "$ANS" in
    	"quit")
        	show "Exiting..."
        	pkill trackMe
        	exit
       ;;
    	"new")
        	ANS=$(show "Enter name of new activity:")
       ;;
	esac
	ACTIVITY=$(parseSpaces "$ANS")

	if [[ "$ACTIVITY" == "" ]]; then
    	show "You must enter a valid activity name."
    	startActivity "$PROJECT"
    	return
	fi

	START=$(date +%s)

	echo "$CLIENT" >> "$ACTIVE"
	echo "$ACTIVITY" >> "$ACTIVE"
	echo "$PROJECT" >> "$ACTIVE"
	echo "$START" >> "$ACTIVE"

	show "$(parseUnderscores $ACTIVITY)@$(parseUnderscores $PROJECT) started at $(date --date="@$START")"
}

createAndSaveStopEvent()
{
    START="$1"
    END="$2"
    ACTIVITY="$3"
    PROJECT="$4"

    echo "Duration: $(diff "$START" "$END")" >> "$EVENT_FILE"
    echo "Ended at $(date --date="@$END")" >> "$EVENT_FILE"
    echo "Started at $(date --date="@$START")" >> "$EVENT_FILE"
    echo "Activity: $ACTIVITY" >> "$EVENT_FILE"
    echo "Project: $PROJECT" >> "$EVENT_FILE"
    echo "Client: $CLIENT" >> "$EVENT_FILE"
}

saveActivity()
{
    START="$1"
    END="$2"
    ACTIVITY="$3"
    PROJECT="$4"

    echo "Started at $(date --date="@$START")" >> "$PROJECTS/$PROJECT/$ACTIVITY"
    echo "Ended at $(date --date="@$END")" >> "$PROJECTS/$PROJECT/$ACTIVITY"
    echo "Duration: $(diff "$START" "$END")" >> "$PROJECTS/$PROJECT/$ACTIVITY"

    if [[ "$GITSYNC" == "yes" ]]; then
        gitAdd "$CLIENT/$PROJECT/$ACTIVITY" & disown
    fi
}

stopActivity()
{
    if [ ! -f "$ACTIVE" ]; then
        show "No timer active, start one?"
        return
    fi

    START=$(tail -n 1 "$ACTIVE")
    END=$(date +%s)
    ACTIVITY=$(tail -n 3 "$ACTIVE" | head -n 1)
    PROJECT=$(tail -n 3 "$ACTIVE" | head -n 2 | tail -n 1)

    saveActivity "$START" "$END" "$ACTIVITY" "$PROJECT"
    createAndSaveStopEvent "$START" "$END" "$ACTIVITY" "$PROJECT"
    rm "$ACTIVE"

    if [[ "$GITSYNC" == "yes" ]]; then
        gitPush "$ACTIVITY" "$PROJECT" & disown
    fi

    show "Time entry added to $(parseUnderscores "$ACTIVITY")!"
}

updateActiveState()
{
    START="$1"
    ACTIVITY="$2"
    PROJECT="$3"

    rm "$ACTIVE"

	echo "$CLIENT" >> "$ACTIVE"
	echo "$ACTIVITY" >> "$ACTIVE"
	echo "$PROJECT" >> "$ACTIVE"
	echo "$START" >> "$ACTIVE"
}

editRunning()
{
    if [ ! -f "$ACTIVE" ]; then
        show "No timer active, start one?"
        return
    fi

    START=$(tail -n 1 "$ACTIVE")
    ACTIVITY=$(tail -n 3 "$ACTIVE" | head -n 1)
    PROJECT=$(tail -n 3 "$ACTIVE" | head -n 2 | tail -n 1)

	CHOICE="$(show "Choose what to edit:" "Start Project Activity")"

	case "$CHOICE" in
        "Start")
            ANS=$(show "Enter new start time: ")
            if [ -z "$ANS" ]; then
                show "No change..."
                return
            fi
            START=$(date --date $ANS +%s)
        ;;
        "Project")
            ANS=$(show "Enter new project name: " "$(ls $PROJECTS)")
            if [ -z "$ANS" ]; then
                show "No change..."
                return
            fi
            rmdir "$PROJECTS/$PROJECT" &> /dev/null
            PROJECT=$(parseSpaces "$ANS")

            if [ ! -d "$PROJECTS/$PROJECT" ]; then
                mkdir "$PROJECTS/$PROJECT"
            fi
        ;;
        "Activity")
            ANS=$(show "Enter new project name: " "$ACTIVITY $(ls $PROJECTS/$PROJECT)")
            if [ -z "$ANS" ]; then
                show "No change..."
                return
            fi
            ACTIVITY=$(parseSpaces "$ANS")
        ;;
        *)
        show "No such alternative, try agian"
        ;;
	esac

    updateActiveState "$START" "$ACTIVITY" "$PROJECT"

	show "$(parseUnderscores $ACTIVITY)@$(parseUnderscores $PROJECT) started at $(date --date="@$START")"
}

################
# Calculations #
################

diff()
{
	let "DIFF = $2 - $1"
	let "SECONDS = DIFF % 60"
	let "MINUTES = (DIFF % 3600) / 60"
	let "HOURS = DIFF / 3600"

	echo "$HOURS:$MINUTES:$SECONDS"
}

sum()
{
    DURATION="$1"

    NEXT_H="$(sed -n -e 's/^\(.*\):\(.*\):\(.*\)/\1/p' <<<"$DURATION")"
    NEXT_M="$(sed -n -e 's/^\(.*\):\(.*\):\(.*\)/\2/p' <<<"$DURATION")"
    NEXT_S="$(sed -n -e 's/^\(.*\):\(.*\):\(.*\)/\3/p' <<<"$DURATION")"
    let "HOURS = $HOURS + 10#$NEXT_H"
    let "MINUTES = $MINUTES + 10#$NEXT_M"
    let "SEC = $SEC + 10#$NEXT_S"
}

extractAndSumEntries()
{
    LIMIT="$1"
    local COUNT=1

    while IFS= read -r line || [ -n "$line" ]; do
        case "$COUNT" in
            "1")
                local CLIENT="$line"
                ;;
            "2")
                local PROJECT="$line"
                ;;
            "3")
                local ACTIVITY="$line"
                ;;
            "4")
                local START_TIME="$line"
                START_TIME_SEC="$(date --date "$(cut -d' ' -f1,2 --complement <<<"$line")" +%s)"

                if [[ "$START_TIME_SEC" < "$LIMIT" ]]; then
                    break;
                fi
                ;;
            "5")
                # Not used at the moment
                #local END_TIME="$line"
                ;;
            "6")
                local DURATION="$line"
                sum "$(cut -d' ' -f2 <<<"$DURATION")" #"$START_TIME" "$ACTIVITY" "$PROJECT" "$CLIENT"
                COUNT=0
                ;;
            *)
                printf '%s%s\n' "COUNT has invalid value: " "$COUNT"
                ;;
        esac
        COUNT=$((COUNT+1))
    done < <(tac "$EVENT_FILE")
}

sumEntries()
{
    if [[ -z "$1" ]]; then
        NOW="$(date +%s)"
        TWELVE_HOURS="$((3600*12))"
        LIMIT="$((NOW - TWELVE_HOURS))"
    else
        LIMIT="$(date --date "$1" +%s)"
    fi

    local HOURS=0
    local MINUTES=0
    local SEC=0

    extractAndSumEntries "$LIMIT"

    let "HOURS = $HOURS + ($MINUTES + $SEC / 60) / 60"
	let "MINUTES = ($MINUTES + $SEC / 60) % 60"
	let "SEC = $SEC % 60"
	show "Total time = $HOURS:$MINUTES:$SEC"
}


sumActivity()
{
	ACTIVITY="$1"

    for DURATION in $(sed -n '0~3p' "$ACTIVITY" | cut -d' ' -f2); do
	    sum "$DURATION"
    done
}

sumProject()
{
	PROJECT="$1"

	for ACTIVITY in $(ls "$PROJECT"); do
		sumActivity "$PROJECT/$ACTIVITY"
	done

	let "HOURS = $HOURS + ($MINUTES + $SEC / 60) / 60"
	let "MINUTES = ($MINUTES + $SEC / 60) % 60"
	let "SEC = $SEC % 60"
}

summarize()
{
	PROJECT="$1"

	local HOURS=0
	local MINUTES=0
	local SEC=0

	ANS="$(show "Choose one activity, (a)ll activities or time or (q)uit" "$(ls $PROJECTS/$PROJECT)")"
	CHOICE="$(parseSpaces "$ANS")"

	case "$CHOICE" in 
    	"q")
        	exit
    	;;
    	"a")
        	sumProject "$PROJECTS/$PROJECT"
	        show "Total time = $HOURS:$MINUTES:$SEC"
    	;;
    	*)
        	pushd "$PROJECTS/$PROJECT" > /dev/null
        	for ACTIVITY in *; do
            	if [[ "$CHOICE" == "$ACTIVITY" ]]; then
                	sumActivity "$PROJECTS/$PROJECT/$CHOICE"
	                let "HOURS = $HOURS + ($MINUTES + $SEC / 60) / 60"
	                let "MINUTES = ($MINUTES + $SEC / 60) % 60"
	                let "SEC = $SEC % 60"
	                show "Total time = $HOURS:$MINUTES:$SEC"
                	popd > /dev/null
                	return
            	fi
        	done
        	show "Activity \"$CHOICE\" does not exist, try again or exit (q)."
        	summarize "$PROJECT"
        	;;
	esac
}

#############
# Main loop #
#############

main()
{
	if [[ ! -f "$ACTIVE" ]]; then
		chooseClient
		if [[ -z "$ANS" ]]; then
            main
            exit
        fi
	else
    	CLIENT=$(head -n 1 "$ACTIVE")
    	show "Client $(parseUnderscores "$CLIENT") is running a timer."
	fi
	PROJECTS="$CLIENTS/$CLIENT"

	while true; do
		ANS="$(show "$CLIENT: What do you want to do?" "start stop edit status summarize help switch quit")"
		CHOICE="$ANS"
    	case "$CHOICE" in
        	"start")
            	if [[ -f "$ACTIVE" ]]; then
                	show "A timer is already running..."
            	else
                	chooseProject "startActivity"
            	fi
            	;;
        	"summarize")
            	chooseProject "summarize"
            	;;
        	"stop")
            	stopActivity
            	;;
        	"status")
            	showStatus
            	;;
        	"help")
            	show "TrackMe - A time tracking program" "Usage: trackme [option] Options: start        - start a timer stop         - stop a running timer, if one exists. status       - check status of running timer, if any. summarize    - summarize time for a specified project and/or activity "
            	;;
        	"switch")
            	main
            	exit
            	;;
            "edit")
                editRunning
                ;;
        	"quit")
            	exit
            	;;
    	esac
	done
}

#############
# Call main #
#############

main
